shiny::runApp('UW/sp2017/INFO201/twitter-weather')
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
runApp('UW/sp2017/INFO201/twitter-weather')
source('scripts/setup.R')
#libraries
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
library(rjson)
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
shiny::runApp('UW/sp2017/INFO201/weather-app')
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, "f2816b4bb0266a96e77991a187b35d9c", "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
location.timezone <- weather.results$timezone
weather.df <- weather.results$hourly$data
weather.df <- ldply(weather.df, data.frame)
num.time <- as.numeric(weather.df$time)
weather.df$time <- anytime(num.time, tz = location.timezone, asUTC = FALSE)
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
num.time <- as.numeric(weather.df$time)
anytime(num.time, tz = location.timezone, asUTC = FALSE)
runApp('UW/sp2017/INFO201/weather-app')
shiny::runApp()
runApp()
runApp()
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp()
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
library(shinyjs)
install.packages("shinyjs")
library(shinyjs)
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
setwd("~/Jobs/Spring 2017/DMEN Assistant/dmen-vis")
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
library(dplyr)
library(xlsx)
library(plotly)
library(ggplot2)
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
scanGraphData <- function(raw.scans.file, raw.sparklink.file = NULL) {
# Remove all rows before the rows that contain diameter and count data
diameter.row.index <- grep("^Raw", raw.scans.file[,1])
raw.scans.df <- raw.scans.file[diameter.row.index:nrow(raw.scans.file),]
# Change column names to the first row (which contains names of relevant data)
colnames(raw.scans.df) <- raw.scans.df[1,]
raw.scans.df <- raw.scans.df[-1,]
# Filter out data that is not relevant to scans (gets all count data and diameters)
filtered.scans <- raw.scans.df %>% select(starts_with("Count"))
diameters <- raw.scans.df %>% select(`Diameter #1`)
# Remove first two scans of six scans
filtered.scans <- nthDelete(filtered.scans, 6, 1)
filtered.scans <- nthDelete(filtered.scans, 5, 1)
# Converts data frames to numeric matrix to allow binary operations (limitation of R)
filtered.scans <- (as.data.frame(lapply(filtered.scans, as.numeric)))
diameters <- (as.data.frame(lapply(diameters, as.numeric)))
# Apply formula to scan data
filtered.scans[,1:ncol(filtered.scans)] <- filtered.scans[,1:ncol(filtered.scans)] *
((25.02 * exp(-0.2382 * diameters$Diameter..1)) + # formula starts here
(950.9 * exp(-1.017 * diameters$Diameter..1)) + 1)
# Adds the diameter data to the filtered scan data
filtered.scans <- cbind(diameters, filtered.scans)
# Size of vector (data structure holding the sample data) is set to number of samples
scan.graph.data <- vector("list", (ncol(filtered.scans)/4))
# Index is pointer for traversing through filtered data
scan.index <- 1
# Split the filtered scans dataframe into smaller dataframes - each corresponding to a sample, with corresponding scan data and diameters
# Local polynomical regression is applied to predict data
# i.e: sample1 --- example of dataframes that populate the vector
#     scan1             -0.466  -0.431 -0.431 -0.419 -0.419 ...
#     scan2             -0.491  -0.491 -0.491 -0.479 -0.479
#     scan3             -0.304  -0.304 -0.304 -0.293 -0.293
#     scan4             -0.335  -0.335 -0.335 -0.324 -0.324
#     sample.diameters   5.97    5.97   5.97   5.98   5.98
for (i in 1:length(scan.graph.data)) {
sample.data <- data.frame(      # NOTE: loess rounds down the rows in the given data
scan1 = filtered.scans[,scan.index + 1],
scan2 = filtered.scans[,scan.index + 2],
scan3 = filtered.scans[,scan.index + 3],
scan4 = filtered.scans[,scan.index + 4]
)
# Adds sample dataframe to the vector that will contain all sample data frames
scan.graph.data[[i]] <- sample.data
# Updates index so the next set of scans can be retrieved
scan.index <- scan.index + 4
}
# Set the names of the sample data frames
# If sparklink file was provided, get names from sparklink file. Else, set to default.
if (!(is.null(raw.sparklink.file))) {
sample.names <- raw.sparklink.file %>% select(Sample.Name)
names(scan.graph.data) <- sample.names[,1]
} else {
names(scan.graph.data) <- c(paste0("sample ", 1:length(scan.graph.data)))
}
return(scan.graph.data)
}
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
test2 <- scanGraphData(read.csv("data\\170522_new_data_format_for_JC_DMA.csv", stringsAsFactors = FALSE))
test2 <- curr.scan.state
curr.scan.state <- test2
loess.graph.data <- curr.scan.state[1:4]
curr.scan.state <- test2$`sample 1`
loess.graph.data <- curr.scan.state[1:4]
scan.graph.data <- cbind(scan.graph.data, diameters)
test2 <- scanGraphData(read.csv("data\\170522_new_data_format_for_JC_DMA.csv", stringsAsFactors = FALSE))
test2 <- scanGraphData(read.csv("data\\170522_new_data_format_for_JC_DMA.csv", stringsAsFactors = FALSE))
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
scanGraphData <- function(raw.scans.file, raw.sparklink.file = NULL) {
# Remove all rows before the rows that contain diameter and count data
diameter.row.index <- grep("^Raw", raw.scans.file[,1])
raw.scans.df <- raw.scans.file[diameter.row.index:nrow(raw.scans.file),]
# Change column names to the first row (which contains names of relevant data)
colnames(raw.scans.df) <- raw.scans.df[1,]
raw.scans.df <- raw.scans.df[-1,]
# Filter out data that is not relevant to scans (gets all count data and diameters)
filtered.scans <- raw.scans.df %>% select(starts_with("Count"))
diameters <- raw.scans.df %>% select(`Diameter #1`)
# Remove first two scans of six scans
filtered.scans <- nthDelete(filtered.scans, 6, 1)
filtered.scans <- nthDelete(filtered.scans, 5, 1)
# Converts data frames to numeric matrix to allow binary operations (limitation of R)
filtered.scans <- (as.data.frame(lapply(filtered.scans, as.numeric)))
diameters <- (as.data.frame(lapply(diameters, as.numeric)))
# Apply formula to scan data
filtered.scans[,1:ncol(filtered.scans)] <- filtered.scans[,1:ncol(filtered.scans)] *
((25.02 * exp(-0.2382 * diameters$Diameter..1)) + # formula starts here
(950.9 * exp(-1.017 * diameters$Diameter..1)) + 1)
# Adds the diameter data to the filtered scan data
filtered.scans <- cbind(diameters, filtered.scans)
# Size of vector (data structure holding the sample data) is set to number of samples
scan.graph.data <- vector("list", (ncol(filtered.scans)/4))
# Index is pointer for traversing through filtered data
scan.index <- 1
# Split the filtered scans dataframe into smaller dataframes - each corresponding to a sample, with corresponding scan data and diameters
# Local polynomical regression is applied to predict data
# i.e: sample1 --- example of dataframes that populate the vector
#     scan1             -0.466  -0.431 -0.431 -0.419 -0.419 ...
#     scan2             -0.491  -0.491 -0.491 -0.479 -0.479
#     scan3             -0.304  -0.304 -0.304 -0.293 -0.293
#     scan4             -0.335  -0.335 -0.335 -0.324 -0.324
#     sample.diameters   5.97    5.97   5.97   5.98   5.98
for (i in 1:length(scan.graph.data)) {
sample.data <- data.frame(      # NOTE: loess rounds down the rows in the given data
scan1 = filtered.scans[,scan.index + 1],
scan2 = filtered.scans[,scan.index + 2],
scan3 = filtered.scans[,scan.index + 3],
scan4 = filtered.scans[,scan.index + 4]
)
# Adds sample dataframe to the vector that will contain all sample data frames
sample.data <- sample.data %>% mutate("sample.diameters" = filtered.scans$`Diameter..1`)
scan.graph.data[[i]] <- sample.data
# Updates index so the next set of scans can be retrieved
scan.index <- scan.index + 4
}
# Set the names of the sample data frames
# If sparklink file was provided, get names from sparklink file. Else, set to default.
if (!(is.null(raw.sparklink.file))) {
sample.names <- raw.sparklink.file %>% select(Sample.Name)
names(scan.graph.data) <- sample.names[,1]
} else {
names(scan.graph.data) <- c(paste0("sample ", 1:length(scan.graph.data)))
}
return(scan.graph.data)
}
test2 <- scanGraphData(read.csv("data\\170522_new_data_format_for_JC_DMA.csv", stringsAsFactors = FALSE))
test3 <- scanGraphData(read.csv("data\\AIMDataset2.csv", stringsAsFactors=FALSE))
curr.scan.state <- test2[[1]]
testSSE <- calcSSE(curr.scan.state[1:4], curr.scan.state$sample.diameters)
calcSSE <- function(data.set, y.axis){
data.set.state <- data.set
data.set.state$index <- 1:nrow(data.set)
loessMod <- try(loess(y.axis ~ index, data=data.set.state, span=x), silent=T)
res <- try(loessMod$residuals, silent=T)
if(class(res)!="try-error"){
if((sum(res, na.rm=T) > 0)){
sse <- sum(res^2)
}
}else{
sse <- 99999
}
return(sse)
}
testSSE <- calcSSE(curr.scan.state[1:4], curr.scan.state$sample.diameters)
testSSE <- calcSSE(curr.scan.state[1:4], curr.scan.state$scan1)
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loess.filter,
smooth.span = as.numeric(smoothing.span)))
loessFilter <- function(x, smooth.span) {
model <- loess(x~curr.scan.state$sample.diameters, curr.scan.state, span = smooth.span)
predict(model)
}
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loessFilter,
smooth.span = as.numeric(smoothing.span)))
smoothing.span <- 0.05
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loessFilter,
smooth.span = as.numeric(smoothing.span)))
sample.rows <- length(loess.graph.data$scan1)
loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
curr.scan.state <- test3[[1]]
loess.graph.data <- curr.scan.state[1:4]
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loessFilter,
smooth.span = as.numeric(smoothing.span)))
View(loess.graph.data)
loessFilter <- function(x, smooth.span) {
model <- loess(curr.scan.state$scan1~curr.scan.state$sample.diameters, curr.scan.state, span = smooth.span)
predict(model)
}
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loessFilter,
smooth.span = as.numeric(smoothing.span)))
loessFilter <- function(x, smooth.span) {
predict(loess(curr.scan.state$scan1~curr.scan.state$sample.diameters, curr.scan.state, span = smooth.span))
}
loess.graph.data <- as.data.frame(lapply(loess.graph.data, loessFilter,
smooth.span = as.numeric(smoothing.span)))
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
curr.scan.state <- test2[[1]]
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = 0.05))
)
sample.rows <- length(loess.graph.data$scan1)
loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
smoothing.span <- 0.05
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span))
)
sample.rows <- length(loess.graph.data$scan1)
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
curr.scan.state <- test3[[1]]
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span))
)
curr.scan.state <- test2[[1]]
loess.graph.data <- data.frame(
scan1 = predict(loess(curr.scan.state[,1] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan2 = predict(loess(curr.scan.state[,2] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan3 = predict(loess(curr.scan.state[,3] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span)),
scan4 = predict(loess(curr.scan.state[,4] ~  curr.scan.state$sample.diameters, curr.scan.state, span = smoothing.span))
)
shiny::runApp()
runApp()
runApp()
runApp()
