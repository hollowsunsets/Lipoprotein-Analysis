shiny::runApp('dmen-vis')
runApp('dmen-vis')
findDissimilarScan <- function(current.graph.data, difference.tolerance = 0.90) {
badScans <- c() # Default value of badScans is NULL
# Removes all NA values from the scan data frame, if any
current.graph.data <- current.graph.data[complete.cases(current.graph.data),]
# Retrieves the scan names from the given data
current.scan.names <- names(select(current.graph.data, starts_with("scan")))
# Finds up to 5 local maxima for each scan in the scan dataset.
# 700 and 1:5 are arbitarily defined.
# 700 is a metric that impacts the sensitivity of the algorithm
# that finds the maximums.
scan.maxima <- data.frame("maximums" = lapply(current.scan.names,
function (x) {
findLocalMaxima(
current.graph.data$sample.diameters,
current.graph.data[[x]], 700)[1:5]
}
), stringsAsFactors = FALSE)
# Names are added to the scan maximums to distinguish the maxima sets from one another
names(scan.maxima) <- current.scan.names
# Removes NA values (these seem to show up in some cases, haven't had the time to check why)
scan.maxima <- scan.maxima[complete.cases(scan.maxima),]
#
scan.maxima <- t(scan.maxima)
# this is actually horrible. pretty sure I won't remember how this works tomorrow
# TO-DO: reimplement this flaming garbage heap w/ mapply when time is available
maxima.similarities <- lapply(c(1:ncol(scan.maxima)), function(z) { # for each column in scan.maximums
lapply(seq_along(scan.maxima[,z]), function(x) { # for each element in the column
mean( # calculate the mean
sapply(seq_along(scan.maxima[,z][1: length(scan.maxima[,z]) - 1]), # for the number of elements in the column - 1 (because we are comparing to every element except itself)
function(y) {
findSimilarity(scan.maxima[,z][x], scan.maxima[,z][-x][[y]]) # the similarity for each element
# compared to all other elements in the column except itself
})
)
})
})
maxima.similarities.reshaped <- NULL
# this just reorganizes the data so all of the corresponding maxima are in one column, rather
# than having all of the maxima for one scan be represented in one column
# prev format: scan1: 8.9 10.4 15.6
# new format: maxima 1: 8.9 8.11 9.1
# this makes the maxima easier to compare
maxima.similarities.reshaped <- as.data.frame(sapply(c(1:length(maxima.similarities)),
function(x) { cbind(maxima.similarities.reshaped,
unlist(maxima.similarities[[x]]))}))
# Calculates the mean of each maxima for each scan
if (ncol(maxima.similarities.reshaped) > 1) {
similarity.metrics <- as.data.frame(cbind(unlist(lapply(c(1:nrow(maxima.similarities.reshaped)),
function(x) mean(as.numeric(maxima.similarities.reshaped[x,]),
na.rm = FALSE)))))
} else {
similarity.metrics <- maxima.similarities.reshaped
}
# Adds names to the similarity metrics dataframe so they can be accessed
similarity.metrics$scan.names <- current.scan.names
# Records the bad scans, if there are any.
for (i in 1:nrow(similarity.metrics)) {
if (similarity.metrics$V1[i] < mean(similarity.metrics$V1)) {
badScans <- c(similarity.metrics$scan.names[i], badScans)
}
}
# If there are no bad scans, return a list containing "None" (assuming that the functions using this expect a list)
# Otherwise, return the list of bad scans.
if (is.null(badScans)) {
return(c(""))
} else {
return(badScans)
}
}
findLocalMaxima <- function(x, y, w = 1) {
n <- length(y)
y.max <- rollapply(zoo(y), 2 * w + 1, max, align = "center")
delta <- y.max - y[-c(1:w, n + 1 - 1:w)]
i.max <- which(delta <= 0) + w
return(unique(y[i.max]))
}
install.packages("logging")
shiny::runApp('dmen-vis')
scans.file <- read.csv("data\\170712_Study115_Batch3_AIMScans.csv", na.strings = c("", "NA"), stringsAsFactors=FALSE)
sparklink.file <- read.csv("data\\170712_Study115_Batch3_Runlist.csv", stringsAsFactors = FALSE, header = FALSE)
setwd("~/dmen-vis")
scans.file <- read.csv("data\\170712_Study115_Batch3_AIMScans.csv", na.strings = c("", "NA"), stringsAsFactors=FALSE)
sparklink.file <- read.csv("data\\170712_Study115_Batch3_Runlist.csv", stringsAsFactors = FALSE, header = FALSE)
