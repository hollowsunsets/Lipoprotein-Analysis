shiny::runApp('UW/sp2017/INFO201/twitter-weather')
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
runApp('UW/sp2017/INFO201/twitter-weather')
source('scripts/setup.R')
#libraries
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
library(rjson)
library(anytime)
library(shiny)
library(dplyr)
library(plotly)
library(httr)
library(rgeos)
library(jsonlite)
library(rgdal)
library(rtweet)
library(stringr)
shiny::runApp('UW/sp2017/INFO201/weather-app')
lat.long.df <- geo_data %>% findLatLong(city, state)
longitude <- lat.long.df[,1]
latitude <- lat.long.df[,2]
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
unix.time.day <- as.numeric(as.POSIXct(anydate(day)))
base.url <- "https://api.darksky.net/forecast/"
weather.uri <- paste0(base.url, "f2816b4bb0266a96e77991a187b35d9c", "/", latitude, ",", longitude, ",", unix.time.day)
weather.params <- list(exclude = paste0("currently", ",", "minutely", ",", "daily", ",", "flags"))
weather.response <- GET(weather.uri, query = weather.params)
weather.body <- content(weather.response, "text")
weather.results <- fromJSON(weather.body)
location.timezone <- weather.results$timezone
weather.df <- weather.results$hourly$data
weather.df <- ldply(weather.df, data.frame)
num.time <- as.numeric(weather.df$time)
weather.df$time <- anytime(num.time, tz = location.timezone, asUTC = FALSE)
weather.df$time.only <- format(as.POSIXct(weather.df$time) , format = "%H:%M:%S")
num.time <- as.numeric(weather.df$time)
anytime(num.time, tz = location.timezone, asUTC = FALSE)
runApp('UW/sp2017/INFO201/weather-app')
shiny::runApp()
runApp()
runApp()
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp()
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
library(shinyjs)
install.packages("shinyjs")
library(shinyjs)
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
loess.filter <- function (x, span) loess(formula = paste(x, "id", sep = "~"),
data = dat,
degree = 1,
span = span)$fitted
curr.scan.state <- graph.data$`sample 1`
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
vars <- colname(curr.scan.state)
id <- 1:nrow(curr.scan.state)
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[[1,]])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state)
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
vars <- colnames(curr.scan.state)
id <- 1:nrow(curr.scan.state)
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[[1,]])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state)
loess.filter <- function (x, span, raw.data) loess(formula = paste(x, "id", sep = "~"),
data = raw.data,
degree = 1,
span = span)$fitted
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
vars <- colnames(curr.scan.state)
id <- 1:nrow(curr.scan.state)
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state), raw.data = curr.scan.state)
sample.rows <- length(loess.graph.data[[1,]])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state)
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
vars <- colnames(curr.scan.state)
id <- 1:nrow(curr.scan.state)
loess.filter <- function (x, span, raw.data) loess(formula = paste(x, "id", sep = "~"),
data = curr.scan.state,
degree = 1,
span = span)$fitted
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[[1,]])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state)
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
## response
vars <- colnames(curr.scan.state)
## covariate
id <- 1:nrow(curr.scan.state)
## define a loess filter function (fitting loess regression line)
loess.filter <- function (x, span) loess(formula = paste(x, "id", sep = "~"),
data = curr.scan.state,
degree = 1,
span = span)$fitted
## apply filter column-by-column
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[[1,]])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state, 0.5)
curr.scan.state <- graph.data$`sample 1`
curr.scan.state <- graph.data$`sample 1`
vars <- colnames(curr.scan.state)
id <- 1:nrow(curr.scan.state)
loess.filter <- function (x, span) loess(formula = paste(x, "id", sep = "~"),
data = curr.scan.state,
degree = 1,
span = span)$fitted
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
smoothing.span <- 0.5
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[[1,]])
sample.rows <- length(loess.graph.data[[1,]])
sample.rows <- length(loess.graph.data[1,])
sample.rows <- length(loess.graph.data[1,1])
View(curr.scan.state)
sample.rows <- length(loess.graph.data[,1])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
applyLoessSmooth <- function(curr.scan.state, smoothing.span) {
## response
vars <- colnames(curr.scan.state)
## covariate
id <- 1:nrow(curr.scan.state)
## define a loess filter function (fitting loess regression line)
loess.filter <- function (x, span) loess(formula = paste(x, "id", sep = "~"),
data = curr.scan.state,
degree = 1,
span = span)$fitted
## apply filter column-by-column
loess.graph.data <- as.data.frame(lapply(vars, loess.filter, span = smoothing.span),
col.names = colnames(curr.scan.state))
sample.rows <- length(loess.graph.data[,1])
loess.graph.data <- loess.graph.data %>% mutate("sample.diameters" = curr.scan.state$sample.diameters[1:sample.rows])
}
test.loess <- applyLoessSmooth(curr.scan.state, 0.5)
curr.scan.state <- dropScan(curr.scan.state, "scan1")
test.loess <- applyLoessSmooth(curr.scan.state, 0.5)
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
# --------------------- Dependencies ---------------------------
library(dplyr) # dependency for general data wrangling
library(xlsx) # dependency for reading in .xlsx files
library(lubridate) # dependency for manipulating timestamps
# --------------------- Test Variables --------------------------
# raw.scans.file <- read.csv("data\\170522_new_data_format_for_JC_DMA.csv", na.strings = c("", "NA"), stringsAsFactors=FALSE)
# raw.scans.file <- read.csv("data\\AIMDataset2.csv", na.strings = c("", "NA"), stringsAsFactors=FALSE)
# raw.sparklink.file <- read.csv("data\\170622_Study114_Runlist.csv", stringsAsFactors = FALSE)
# Note: na.strings = c("", "NA") is necessary for time stamps to be retrieved properly
# ---------------------- Functions -------------------------------
# With the given scan files, returns a data frame that has
# contains the relevant scan data, prepared to be graphed.
scanGraphData <- function(raw.scans.file, raw.sparklink.file = NULL) {
# Remove all rows before the rows that contain diameter and count data
diameter.row.index <- grep("^Raw", raw.scans.file[,1])
raw.scans.df <- raw.scans.file[diameter.row.index:nrow(raw.scans.file),]
# Change column names to the first row (which contains identifiers of samples)
colnames(raw.scans.df) <- raw.scans.df[1,]
raw.scans.df <- raw.scans.df[-1,]
# Filter out data that is not relevant to scans (gets all count data and diameters)
filtered.scans <- raw.scans.df %>% select(starts_with("Count"))
diameters <- raw.scans.df %>% select(`Diameter #1`)
# Remove first two scans of six scans
filtered.scans <- nthDelete(filtered.scans, 6, 1)
filtered.scans <- nthDelete(filtered.scans, 5, 1)
# Converts data frames to numeric matrix to allow binary operations (limitation of R)
filtered.scans <- (as.data.frame(lapply(filtered.scans, as.numeric)))
diameters <- (as.data.frame(lapply(diameters, as.numeric)))
# Apply formula to scan data
filtered.scans[,1:ncol(filtered.scans)] <- filtered.scans[,1:ncol(filtered.scans)] *
((25.02 * exp(-0.2382 * diameters$Diameter..1)) + # formula starts here
(950.9 * exp(-1.017 * diameters$Diameter..1)) + 1)
# Adds the diameter data to the filtered scan data
filtered.scans <- cbind(diameters, filtered.scans)
# Size of vector (data structure holding the sample data) is set to number of samples
scan.graph.data <- vector("list", (ncol(filtered.scans)/4))
# Index is pointer for traversing through filtered data
scan.index <- 1
# Split the filtered scans dataframe into smaller dataframes - each corresponding to a sample,
# with corresponding scan data and diameters
# i.e: sample1 --- example of dataframes that populate the vector
#     scan1             -0.466  -0.431 -0.431 -0.419 -0.419 ...
#     scan2             -0.491  -0.491 -0.491 -0.479 -0.479
#     scan3             -0.304  -0.304 -0.304 -0.293 -0.293
#     scan4             -0.335  -0.335 -0.335 -0.324 -0.324
#     sample.diameters   5.97    5.97   5.97   5.98   5.98
for (i in 1:length(scan.graph.data)) {
sample.data <- data.frame(
scan1 = filtered.scans[,scan.index + 1],
scan2 = filtered.scans[,scan.index + 2],
scan3 = filtered.scans[,scan.index + 3],
scan4 = filtered.scans[,scan.index + 4]
)
# Adds sample dataframe to the vector that will contain all sample data frames
sample.data <- sample.data %>% mutate("sample.diameters" = filtered.scans$`Diameter..1`)
scan.graph.data[[i]] <- sample.data
# Updates index so the next set of scans can be retrieved
scan.index <- scan.index + 4
}
# Set the names of the sample data frames
# If sparklink file was provided, get names from sparklink file. Else, set to default.
if (!(is.null(raw.sparklink.file))) {
sample.names.first.row <- colnames(raw.sparklink.file)[3]
sample.names.other.rows <- raw.sparklink.file[,3:4]
if (length(sample.names < length(scan.graph.data))) {
sample.names <- rbind(sample.names,
c(paste0("unlabeled sample ",
length(sample.names):
length(scan.graph.data))))
#   print(sample.names)
}
sample.names <- rbind(sample.names.first.row, sample.names.other.rows)
# print(length(sample.names))
#  print(length(scan.graph.data))
names(scan.graph.data) <- sample.names[,1]
} else {
names(scan.graph.data) <- c(paste0("sample ", 1:length(scan.graph.data)))
}
return(scan.graph.data)
}
# Returns a dataframe containing the corresponding starting and end time stamps
# for each sample (the time during which each sample was run) from the given raw scans file.
scanTimeStamps <- function(raw.scans.file, raw.sparklink.file = NULL) {
# Removes all rows before and after the time stamps and the sample labels.
timestamp.start.index <- grep("^Sample #", raw.scans.file[,1])
timestamp.end.index <- grep("^Start", raw.scans.file[,1])
timestamp.df <- raw.scans.file[timestamp.start.index:timestamp.end.index,]
# Changes the column names of the time stamp dataframe to the first row, then
# deletes the first row.
colnames(timestamp.df) <- timestamp.df[1,]
timestamp.df <- timestamp.df[-1,]
# Selects only the relevant data (in this context only the columns that have information in them)
# All blank columns were set to NA when read in, and are now deleted.
timestamp.df <- timestamp.df[colSums(is.na(timestamp.df)) != nrow(timestamp.df)]
# Remove the first column of the dataframe containing labels
timestamp.df <- timestamp.df[,-1]
# Removes the first two scans of the six scans from the dataset
timestamp.df <- nthDelete(timestamp.df, 6, 1)
timestamp.df <- nthDelete(timestamp.df, 5, 1)
# Creates a dataframe from the start time and date for each scan
final.timestamps <- data.frame(start.time = parse_date_time(paste(timestamp.df[1,],
timestamp.df[2,]),
c("%d/%m/%Y %H:%M:%S",
"%m/%d/%y %H:%M:%S")))
# Creates columns of a rounded down start time and a rounded up end time to represent a flexible
# starting and end time to be graphed for each sample
number.of.samples <- floor((nrow(final.timestamps)/4)) * 4
sample.times <- data.frame(start.time = final.timestamps[(seq(1, to=number.of.samples, by=4)),],
end.time = final.timestamps[(seq(4, to=number.of.samples, by=4)),])
sample.times$start.time <- floor_date(sample.times$start.time, "minute")
sample.times$end.time <- ceiling_date(sample.times$end.time, "minute")
# Data is labeled the same as the scan data itself to facilitate ease of access
if (!(is.null(raw.sparklink.file))) {
sample.names.first.row <- colnames(raw.sparklink.file)[3]
sample.names.other.rows <- raw.sparklink.file[,3:4]
if (nrow(sample.names <  nrow(sample.times))) {
sample.names <- rbind(sample.names,
c(paste0("unlabeled sample ",
nrow(sample.names):
nrow(sample.times))))
#   print(sample.names)
}
sample.names <- rbind(sample.names.first.row, sample.names.other.rows)
print(sample.names)
# print(length(sample.names))
#  print(length(scan.graph.data))
names(sample.times) <- sample.names
} else {
sample.times$sample.name <- c(paste0("sample ", 1:(nrow(sample.times))))
}
return(sample.times)
}
# scan.graph.data <- scanGraphData(raw.scans.file)
# scan.timestamps <- scanTimeStamps(raw.scans.file)
# Function for setting the column names of the graph data so the
# data processing doesn't have to be run through again.
# Assumed format is Sparklink labels format.
setGraphLabels <- function(graph.labels, graph.data) {
names(graph.data) <- graph.labels[,1] # Is this even used? It's just one line and it's already run in the file processing itself
}
# Returns a data frame to be graphed from the given amplog file.
ampGraphData <- function(raw.amplog.file) {
amp.graph.data <- raw.amplog.file %>% select(X1, X3)
return(amp.graph.data)
}
# Get start time
# Get end time
# Create interval that ranges -3 min, +3 min (this improves visibility of data and catches timestamps that don't exactly match)
## i.e: start time = 1:05 PM, end time = 1:15 PM
## interval: 1:02 PM - 1:18 PM
# Get all times and amperage contained within that interval
## Either use [start:end] indexing or use %in% to check inside the interval
intervalAmperageData <- function(amp.graph.data, start.time, end.time) {
selected.interval <- as.interval(start.time - (3 * 60), end.time + (3 * 60))
selected.amp.times <- amp.graph.data[,1][amp.graph.data$X1 %within% selected.interval]
selected.amp.data <- amp.graph.data %>% filter(X1 %in% selected.amp.times)
return(selected.amp.data)
}
# Deletes every nth column in the given data frame, beginning from the
# given starting index, i.
nthDelete <- function(data.frame, n, i) {
data.frame[,-(seq(i, to=ncol(data.frame), by=n))]
}
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
install.packages("readxl")
install.packages("tidyverse")
library(readxl) # dependency for reading in .xlsx files
test <- readxl_example("clippy.xls")
library(readxl)
test <- readxl_example("clippy.xls")
library(readxl)
devtools::install_github("tidyverse/readxl")
library(xlsx)
library(readxl)
test <- read_excel("170622_Study114Amplog.xlsx")
library(dplyr)
library(readxl)
library(plotly)
library(ggplot2)
library(ggvis)
readxltest <- read_excel("wipotrends.xlsx")
readxltest <- read_excel("wipotrends.xlsx")
read_wipo <- read_excel("/wipotrends.xlsx")
read_wipo <- read_excel("//wipotrends.xlsx")
read_wipo <- read_excel('wipotrends.xlsx')
read_wipo <- read_excel('wipotrends.xlsx')
read_wipo <- read_excel('wipotrends.xlsx')
read_wipo <- read_excel('wipotrends.xlsx')
read_wipo <- read_excel('wipotrends.xlsx')
install.packages("readxl")
install.packages("readxl")
shiny::runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
View(raw.scans.file)
View(sample.names)
current.graph.data <- applyLoessSmooth(graph.data[[17]], 0.05)
difference.tolerance <- 0.90
library(shiny)
library(shinyjs)
library(dplyr)
library(ggplot2)
library(reshape2)
library(readxl)
library(lubridate)
library(pracma)
current.graph.data <- applyLoessSmooth(graph.data[[17]], 0.05)
badScans <- c() # Default value of badScans is NULL
current.graph.data <- current.graph.data[complete.cases(current.graph.data),]
test<- c(max(current.graph.data$scan1), max(current.graph.data$scan2), max(current.graph.data$scan3),
max(current.graph.data$scan4))
current.graph.data <- graph.data[[17]]
difference.tolerance <- 0.90
current.graph.data <- current.graph.data[complete.cases(current.graph.data),]
test<- c(max(current.graph.data$scan1), max(current.graph.data$scan2), max(current.graph.data$scan3),
max(current.graph.data$scan4))
findSimilarity(test[1], test[2])
findSimilarity(test[3], test[2])
findSimilarity(test[1], test[3])
findSimilarity(test[1], test[4])
findSimilarity(test[1], test[2])
findSimilarity(test[1], test[3])
findSimilarity(test[1], test[4])
findSimilarity(test[2], test[3])
findSimilarity(test[2], test[4])
findSimilarity(test[2], test[1])
findSimilarity(test[3], test[4])
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
runApp('Jobs/Spring 2017/DMEN Assistant/dmen-vis')
graph.data <- read.csv("data\\170622_Study114_AIM.csv", stringsAsFactors = FALSE, na.strings = c("", NA))
setwd("~/Jobs/Spring 2017/DMEN Assistant/dmen-vis")
graph.data <- read.csv("data\\170622_Study114_AIM.csv", stringsAsFactors = FALSE, na.strings = c("", NA))
graph.data <- scanGraphData(read.csv("data\\170622_Study114_AIM.csv", stringsAsFactors = FALSE, na.strings = c("", NA)))
scan.flags <- integer(length(graph.data))
scan.flags <- rbind(scan.flags, names(graph.data))
scan.flags[which(scan.flags[2,] == "std 1")] <<- 1
scan.flags[which(scan.flags[2,] == "sample 1")] <- 1
scan.flags[which(scan.flags[2,] == "sample 1")] <- 2
scan.flags[which(scan.flags[2,] == "sample 1")] <- 1
scan.flags[which(scan.flags[2,] == "sample 2")] <- 1
View(scan.flags)
scan.flags[which(scan.flags[2,] == "sample 1")] <- 1
scan.flags <- integer(length(graph.data))
scan.flags <- rbind(scan.flags, names(graph.data))
which(scan.flags[2,] == "sample 2")
scan.flags[2]
scan.flags[2,][2]
scan.flags[2,][1]
View(scan.flags)
scan.flags[2,]
scan.flags[2,][2]
scan.flags[2,][which(scan.flags[2,] == "sample 2")] <- 1
View(scan.flags)
scan.flags[3]
scan.flags[4]
scan.flags <- integer(length(graph.data))
scan.flags <- rbind(scan.flags, names(graph.data))
scan.flags[4]
scan.flags[1]
scan.flags[2]
scan.flags[3]
scan.flags[4]
scan.flags[5]
scan.flags[6]
scan.flags[7]
scan.flags[[1]]
scan.flags[[2]]
scan.flags[[3]]
scan.flags[[4]]
scan.flags[[5]]
which(scan.flags[2,] == "sample 2") + 1
(scan.flags[[which(scan.flags[2,] == input$sampleSelect)]] == 0)
(scan.flags[[which(scan.flags[2,] == "sample 2")]] == 0)
(scan.flags[[which(scan.flags[2,] == "sample 2")]])
(scan.flags[[which(scan.flags[2,] == "sample 2") + 1]])
(scan.flags[[which(scan.flags[2,] == "sample 1") + 1]])
graph.data["sample 1"]
which(graph.data["sample 1"])
which(names(graph.data) == "sample 1")
which(names(graph.data) == "sample 2")
which(names(graph.data) == "sample 3")
scan.flags <- integer(length(graph.data))
runApp()
runApp()
runApp()
runApp()
